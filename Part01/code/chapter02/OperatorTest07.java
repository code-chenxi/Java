/*
无符号右移：>>>
	1. 溢出后的截断。
	2. 无符号右移之后，最终的结果一定是0或者正整数。
	3. 无符号右移之后，左侧补0.（不管是正数还是负数，都是补0）
*/
public class OperatorTest07{
	public static void main(String[] args){
		
		/*
			原码：10000000
			反码：11111111
				  10000000（补码）
			      00100000（无符号右移2位）
		*/
		byte b = -128;
		
		/*
			为什么输出结果不是32？
				b >>> 2。
				byte和int混合运算。会先将byte转换成int，再做运算。
			
			int b = -128;
			原码：10000000 00000000 00000000 10000000
			反码：11111111 11111111 11111111 01111111
			补码：11111111 11111111 11111111 10000000
			右移：0011111111 11111111 11111111 100000（补码）
		*/
		//System.out.println(b >>> 2); // 1073741792

		//System.out.println(0b00111111111111111111111111100000); // 1073741792

		// 11100000（补码）
		// 10100000（原码）
		System.out.println((byte)(b >>> 2)); // -32

		/*
			原码：10000000 00000000 00000000 01011010
			反码：11111111 11111111 11111111 10100101
			补码：11111111 11111111 11111111 10100110
			右移：00011111111 11111111 11111111 10100
		*/
		int x = -90;
		System.out.println(x >>> 3);
		System.out.println(0b00011111111111111111111111110100);

		/*
			00000000 00000000 00000000 01011010
			00000000000 00000000 00000000 01011
		*/
		int y = 90;
		System.out.println(y >>> 3); // 11
	}
}